## 第五章 网关项目

### 5.1 公共层

同定位器项目

### 5.3 LoRa 模块

#### ① 原理图

![01-lora-Schematic01.png](https://p.sda1.dev/25/d2233c061e8420d94f5ba1f54ca24a02/01-lora-Schematic01.png)
![01-lora-Schematic02.png](https://p.sda1.dev/25/30610c6360947f0e257cd3aca93b787c/01-lora-Schematic02.png)

#### ② CubeMX 配置

![01-lora-hal01.png](https://p.sda1.dev/25/d1d5fc73afdb983e309c0dd42597f60a/01-lora-hal01.png)
![01-lora-hal02.png](https://p.sda1.dev/25/b489256ba848d2b2e4ef0bbffcbc3c98/01-lora-hal02.png)

#### ③ 代码

同定位器中的 Lora 模块代码

**main.c （演示）**

```c
int main()
{
      // 初始化Lora模块 LLCC68
      Int_LLCC68_Init();

      // 定义数组和变量，用于接收lora数据和保存长度
      uint8_t lora_data[256];
      uint16_t lora_data_len = 0;

  
      while (1)
      {
        // 接收Lora数据
        Int_LLCC68_Receive(lora_data, &lora_data_len);

        // 如果接收到数据
        if (lora_data_len > 0) {
          // 打印接收到的数据
          DEBUG_PRINTLN("Received data: %s", lora_data);
          DEBUG_PRINTLN("Data length: %d", lora_data_len);
          DEBUG_PRINTLN("-----------------------");

          // 清空接收数据
          memset(lora_data, 0, 256);
          lora_data_len = 0;
        }

      }
}
```



### 5 以太网模块

#### ① 原理图

![02-w5500-Schematic01.png](https://p.sda1.dev/25/6be1458442bcdaa0458f37c11711e7ec/02-w5500-Schematic01.png)
![02-w5500-Schematic02.png](https://p.sda1.dev/25/d6a4f2a07bfad51fc155d393bb9b603c/02-w5500-Schematic02.png)

#### ② CubeMX 配置

![02-w5500-hal01.png](https://p.sda1.dev/25/ef5b6f707b901e26508338a472df19f1/02-w5500-hal01.png)
![02-w5500-hal02.png](https://p.sda1.dev/25/cfc88e0d2ae7966abe1c21997b827c7b/02-w5500-hal02.png)

#### ③ W5500 概述

W5500 是一款由韩国[wiznet](https://wiznet.io/)发布的全硬件嵌入式以太网控制器，为嵌入式系统提供了更加简易的互联网连接方案。W5500 集成了 TCP/IP 协议栈，10/100M 以太网数据链路层（MAC）及物理层（PHY），使得用户使用单芯片就能够在他们的应用中拓展网络连接。

##### (1) 结构和特点

![02-W5500-chip06.png](https://p.sda1.dev/25/81f1ad6bfe275cf981175265ae2b28a4/02-W5500-chip06.png)





**特点：**

![02-W5500-chip02.png](https://p.sda1.dev/25/e99d4a2e144a09a9a16a8a26db14ac99/02-W5500-chip02.png)

**引用场景：**

![02-W5500-chip03.png](https://p.sda1.dev/25/f7e880e47b188ee71a96b2748f9ca2ef/02-W5500-chip03.png)

##### (2) 相关引脚

![02-W5500-chip01.png](https://p.sda1.dev/25/a85709af4f553d43972aaa439a84be83/02-W5500-chip01.png)

##### (3) SPI 接口

![02-W5500-chip04.png](https://p.sda1.dev/25/3d1235fcbb1314ca2f8fc269cfd5c198/02-W5500-chip04.png)
![02-W5500-chip05.png](https://p.sda1.dev/25/1035019cbcba4ace4455d0988ff4dd6b/02-W5500-chip05.png)

![02-W5500-chip04-01.png](https://p.sda1.dev/25/0b6d6d73aa5845132bad33e0da84596c/02-W5500-chip04-01.png)

##### (3) 通用寄存器

![02-W5500-chip07-reg1.png](https://p.sda1.dev/25/07a5c10fb180907f54d87ddd69ae0abd/02-W5500-chip07-reg1.png)

##### (5) socket 寄存器

**状态寄存器中的部分标志位：**

![02-W5500-chip07-reg2.png](https://p.sda1.dev/25/b1133bcc5db790e90331410c8cbff55d/02-W5500-chip07-reg2.png)



#### ④ 移植 W5500 官方驱动

##### (1) 移植官方库文件

>  官方库地址：https://github.com/Wiznet/ioLibrary_Driver/tree/master

![02-w5500-driver01.png](https://p.sda1.dev/25/966ac91188cf05afad4d92a94d7a83b4/02-w5500-driver01.png)

**官方驱动库结构：**

![02-w5500-driver02.png](https://p.sda1.dev/25/e43f7d4b7d75531555416097fcc110af/02-w5500-driver02.png)

**Interface 中创建 Eth 目录，然后复制我们需要的文件：**

![02-w5500-driver03.png](https://p.sda1.dev/25/af4d45372a704d28b84e406a7a6ca924/02-w5500-driver03.png)

##### (2)  修改 wizchip_conf.h

找到宏定义 `_WIZCHIP_`，如果不是W5500，就改成W5500：（默认值就是）

![02-w5500-Code01.png](https://p.sda1.dev/25/63363265066197996e4fe4571f18f8be/02-w5500-Code01.png)

修改工作模式为可变数据长度模式：（默认值就是）

![02-w5500-Code02.png](https://p.sda1.dev/25/d2c6c31ae35df10abf0563d4a1d1c7c4/02-w5500-Code02.png)

##### (3) 修改 wizchip_conf.c

将以下四个函数补充完整（sd）：

```c
// 片选使能
void wizchip_cs_select(void)            
{
   // 片选引脚拉低
   HAL_GPIO_WritePin(W5500_CS_GPIO_Port, W5500_CS_Pin, GPIO_PIN_RESET);
}

// 取消片选使能
void 	wizchip_cs_deselect(void)          
{
   // 片选引脚拉高
   HAL_GPIO_WritePin(W5500_CS_GPIO_Port, W5500_CS_Pin, GPIO_PIN_SET);
}

// 通过SPI读1个字节
uint8_t wizchip_spi_readbyte(void)        
{
   uint8_t rx_byte;
   HAL_SPI_Receive(&hspi2, &rx_byte, 1, 1000);
   return rx_byte;
}

// 通过 SPI 写入1个字节
void wizchip_spi_writebyte(uint8_t wb) 
{
   HAL_SPI_Transmit(&hspi2, &wb, 1, 1000);
}
```

添加一个封装注册功能的函数，并在 wizchip_conf.h 中添加原型：

```c
// 函数实现：注册函数
void development_reg_func(void)
{
    // 1. 注册进入和退出临界区的函数
    reg_wizchip_cris_cbfunc(wizchip_cris_enter, wizchip_cris_exit);
    // 2. 注册片选和取消片选的函数
    reg_wizchip_cs_cbfunc(wizchip_cs_select, wizchip_cs_deselect);
    // 3. 注册SPI读写数据的函数
    reg_wizchip_spi_cbfunc(wizchip_spi_readbyte, wizchip_spi_writebyte);
}

```

#### ⑤ 自定义代码

**Int_W5500.h**

```c
#ifndef __INT_W5500_H__
#define __INT_W5500_H__


#include "wizchip_conf.h"
#include "socket.h"

#include "Com_Debug.h"
#include "Com_Util.h"


/**
 * @brief W5500初始化
 */
void Int_W5500_Init(void);

/**
 * @brief 发送数据
 * 
 * @param send_data 要发送的数据 
 * @param send_len  要发送的数据长度
 * @return uint8_t 发送结果，0表示成功，其他值表示失败
 */
uint8_t Int_W5500_Send(uint8_t *send_data, uint16_t send_len);

#endif /* __INT_W5500_H__ */

```

**Int_W5500.c**

```c
#include "Int_W5500.h"

// 定义宏 表示SOCKET编号
#define SOCKET_NUM 0

// 定义本地的IP地址
uint8_t local_ip[4] = {192, 168, 11, 32};
// 定义本地MAC地址
uint8_t local_mac[6] = {0xF8, 0xE5, 0x9B, 0x8B, 0xA4, 0xF7};
// 定义子网掩码
uint8_t subnet_mask[4] = {255, 255, 255, 0};
// 定义网关地址
uint8_t gateway_ip[4] = {192, 168, 11, 1};
// 定义本地端口号
uint16_t local_port = 4587;

// 定义服务器IP地址
uint8_t server_ip[4] = {192, 168, 11, 51};
uint16_t server_port = 8888;

/**
 * @brief W5500初始化
 */
void Int_W5500_Init(void)
{
    // 1. 复位 ------------------
    // 1.1 拉低复位引脚，并至少保持100us，这里延时100ms
    HAL_GPIO_WritePin(W5500_RST_GPIO_Port, W5500_RST_Pin, GPIO_PIN_RESET);
    Com_Delay_ms(100);
    // 1.2 拉高复位引脚，并延时一会以让芯片稳定
    HAL_GPIO_WritePin(W5500_RST_GPIO_Port, W5500_RST_Pin, GPIO_PIN_SET);
    Com_Delay_ms(100);

    // 2. 注册函数 --------------
    development_reg_func();

    // 3. 设置本地IP地址、MAC地址、子网掩码、网关地址
    setSIPR(local_ip);    // 设置IP地址
    setSHAR(local_mac);   // 设置MAC地址
    setSUBR(subnet_mask); // 设置子网掩码
    setGAR(gateway_ip);   // 设置网关地址

    DEBUG_PRINTLN("Ethernet W5500 初始化完成...");
}

/**
 * @brief 发送数据
 *
 * @param send_data 要发送的数据
 * @param send_len  要发送的数据长度
 * @return uint8_t 发送结果，0表示成功，其他值表示失败
 */
uint8_t Int_W5500_Send(uint8_t *send_data, uint16_t send_len)
{
    // 定义变量，保存Socket连接状态
    uint8_t status;

    do
    {
        // 获取SOCKET状态
        status = getSn_SR(SOCKET_NUM);

        // 如果当前连接是关闭的，创建SOCKET客户端
        if (status == SOCK_CLOSED)
        {
            uint8_t socket_status = socket(SOCKET_NUM, Sn_MR_TCP, local_port, 0);
            if (socket_status == SOCKET_NUM)
            {
                DEBUG_PRINTLN("创建SOCKET客户端成功...");
            }
            else
            {
                DEBUG_PRINTLN("创建SOCKET客户端失败...");
            }
        }

        // 如果当前连接是INIT状态，尝试连接服务器
        if (status == SOCK_INIT)
        {
            uint8_t connect_status = connect(SOCKET_NUM, server_ip, server_port);
            if (connect_status == SOCK_OK)
            {
                DEBUG_PRINTLN("连接服务器成功...");
            }
            else
            {
                DEBUG_PRINTLN("连接服务器失败...");
            }
        }

        // 如果是 CLOSE_WAIT 状态，关闭连接
        if (status == SOCK_CLOSE_WAIT)
        {
            close(SOCKET_NUM);
            DEBUG_PRINTLN("关闭连接...");
        }

    } while (status != SOCK_ESTABLISHED); // 等待连接建立成功

    // 发送数据
    uint16_t send_result = send(SOCKET_NUM, send_data, send_len);

    // 检查发送结果
    if (send_result == send_len)
    {
        DEBUG_PRINTLN("发送数据成功...");
        return 0;
    }
    else
    {
        DEBUG_PRINTLN("发送数据失败...");
        return 1;
    }
}

```



#### ⑥ TCP 三次握手

![03-tcp.png](https://p.sda1.dev/25/b52a2333bd1d361337129300e02361c9/03-tcp.png)



![03-tcp2.png](https://p.sda1.dev/25/fbba07f347caf7e565aa0372031788a0/03-tcp2.png)



### 5.3 应用层

**main.c**

```c
/* USER CODE BEGIN Includes */
#include "Com_Debug.h"
#include "Com_Util.h"
#include "Int_LLCC68.h"
#include "Int_W5500.h"
/* USER CODE END Includes */

int main(void)
{

  /* 代码省略 */

  /* USER CODE BEGIN 2 */

  DEBUG_PRINTLN("Location Gateway Project Start: ");

  // 初始化Lora模块 LLCC68
  Int_LLCC68_Init();

  // 初始化W5500
  Int_W5500_Init();
  // 使用W5500向服务器发送数据
  // Int_W5500_Send("Hello,W5500!", 12);

  // 定义数组和变量，用于接收lora数据和保存长度
  uint8_t lora_data[256];
  uint16_t lora_data_len = 0;

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

    // 接收Lora数据
    Int_LLCC68_Receive(lora_data, &lora_data_len);

    // 如果接收到数据
    if (lora_data_len > 0) {
      // 打印接收到的数据
      DEBUG_PRINTLN("Received data: %s", lora_data);
      DEBUG_PRINTLN("Data length: %d", lora_data_len);
      DEBUG_PRINTLN("-----------------------");

      // 使用W5500向服务器发送数据
      Int_W5500_Send(lora_data, lora_data_len);
    
      // 清空接收数据
      memset(lora_data, 0, 256);
      lora_data_len = 0;
    }

  }
  /* USER CODE END 3 */
}

```





## 附录

#### 名词解释

```
NB-IoT: Narrow Band Internet of Things，窄带物联网
LoRa:	Long Range Radio，远距离无线电
LGA:	Land Grid Array，网格阵列封装

CASIC: China Aerospace Science and Industry Corporation, 中国航天科工集团; 也指代其开发的导航通信协议，用于高精度定位和数据传输
NMEA: National Marine Electronics Association, 美国国家海洋电子协会; 也代指其制定的标准通信协议，最初用于航海设备间的数据交换，现已成为GPS导航设备的通用数据格式

DHCP:	Dynamic Host Configuration Protocol，动态主机配置协议
DNS:	Domain Name System

PSM:	Power Saving Mode，节能模式
```

#### 相关单词

```
latitude	纬度
longitude	经度
Ethernet	以太网
Attention	注意；立正；关心
Attach		系上，贴上，连接；附上
established	建立，设立；证实，确定
```

#### 相关工具网址

```
TCP 服务测试工具: https://netlab.luatos.com
C语言标准库手册:  https://en.cppreference.com/w/c/header.html
经纬度定位：https://lbsyun.baidu.com/jsdemo/demo/yLngLatLocation.htm
```

